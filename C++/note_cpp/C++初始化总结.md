# C++初始化问题

## 背景
C++中初始化与赋值不是同一个概念

初始化：创建变量时赋予其一个初始值。
赋值：把对象（已经创建的）的当前值擦除，而用一个新值来代替。

## 列表初始化
使用花括号来初始化变量

```
int a = {0}; //列表初始化1
int a{0};//列表初始化2
```

### 局限
当对内置类型使用列表初始化时，若初始值存在丢失的风险，编译将会报错。

```
int a = 3.14; //正确，虽然会丢失小数部分，但是编译器不会报错。

int a = {3.14}; //错误，因为将会丢失小数部分，g++警告
```

### 扩展
由花括号括起来的初始值，不仅可以用于值初始化变量还可以用于为对象(旧变量)赋新值。

```
int a = 1;
a = {3};
```

### 用处
可以用在任何需要变量初始化的地方，**类成员初始化**，以及for()变量。
```
for (int i{0}; i < 10; ++i) {
    ...
}
```
## 拷贝初始化

如果使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。

```
string s1;  //默认初始化为空字符串
string s2 = s1; //拷贝初始化，s2是s1的副本
```

## 直接初始化

如果在新创建的变量右侧使用括号将初始值括住，则执行的是直接初始化

```
string s1();
string s2("hi");
string s3(3,'c'); //直接初始化，s2的内容是ccc
```
使用圆括号提供初值是用来***构造(construct)**对象，因此可以知道所谓的直接初始化就是显示的调用相应的**构造函数**。

1. 在数组初始化过程中如果提供的初值数量少于数组大小时；
2. 当不使用初始值定义一个局部静态变量时；
3. 当通过T()形式的表达式显示地请求值初始化时(T是类型名)

*explicit构造函数只能用于直接初始化*。

### 特列--vector

vector使用直接初始化时，需要指定一个重复次数
```
vector<string> v1("hello","world");//错误
vector<string> v2{"Hello","world"};//正确
vector<string> v3(2,"helloo"); // 正确
```
当花括号的内容无法进行初始化时，如果符合( )的初始化形式，就进行()括号的初始化。

## 默认初始化
如果定义变量时没有指定初值，则变量被默认初始化，具体的值由变量类型及其所在位置决定。

### 内置类型

#### 局部变量

##### 非static局部变量
在函数体内部的内置类型变量（包括指针）将不被初始化。参考资料[1]P47指出，其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。参考资料[1]P185介绍自动对象的时候，也指出这个问题。
##### static局部变量
如果局部变量没有显式的初始化值，它将执行值初始化（不是默认初始化！），内置类型的局部静态变量初始化为0。

#### 全局变量
初始化为0

### 类类型
类通过一个特殊的构造函数来控制默认初始化过程，这个类叫做默认构造函数，默认构造函数无需任何实参。每个类各自定义其初始化对象的方式（默认构造函数），例如，std::string 不管是定义于局部还是全局，都会默认初始化为空。
```
string a;
tuple<size_t,size_t,size_t> threeD ;//tuple的默认构造函数对每个成员进行值初始化
```
### 例外情况

有些类不支持默认初始化，必须明确地提供初始值，这些类没有默认构造函数，因为在这些类华总
用户已经定义了自己的构造函数，系统将不会生成无參的构造函数，用户需要自己手动编写
无參的构造函数作为默认构造函数。

## 值初始化
只提供**vector**对象容纳元素数量而不提供初始值，此时会创建一个值初始化的元素值，并把它赋值给容器中的所有元素，这个chuzhi初值由vector对象中的元素类型决定。

>对象默认初始化，或值初始化时自动执行默认构造函数。

## 类成员初始化
C++11 新标准规定，可以为类内数据成员提供一个类内初始值，类内初始值只能使用拷贝初始化和列表初始化(不能直接初始化),当我们提供一个类内初始值时，必须以符号=或者花括号表示，没有提供类内初始值的成员将被默认初始化。
```
class A {
    int a{0};
    int b = {1};
    int c = 2;
    int d;
    int e(3);//错误
}

````